#!/bin/zsh
#
# =============================================================================================
# ZSH prestart
# =============================================================================================

autoload -Uz vcs_info

precmd_vcs_info() { vcs_info }
precmd_functions+=( precmd_vcs_info )

setopt PROMPT_SUBST # set up prompt with git branch name
# https://www.ditig.com/256-colors-cheat-sheet
# https://stackoverflow.com/a/2534676
NEWLINE=$'\n'
PROMPT='${NEWLINE}%F{039}%n%f in %F{202}${PWD/#$HOME/~}%f ${vcs_info_msg_0_}
%{$fg[white]%}> %{$reset_color%}'

# Format the vcs_info_msg_0_ variable
# TODO: https://github.com/agnoster/agnoster-zsh-theme (for branch icon from powerline font)
zstyle ':vcs_info:git:*' formats '(on %F{002}%b%f)'


# =============================================================================================
# Helper functions
# =============================================================================================

function pull-all () {
  # Save the original directory
  original_dir="$PWD"

  # Define the base path
  base_path="$HOME/code/src/github.com/org"

  # Define the repository subfolders
  repos=("repo-a" "repo-b" "repo-c")

  # Loop through each repository
  for repo in "${repos[@]}"; do
    repo_path="$base_path/$repo"

      if [[ -d "$repo_path" ]]; then
        pushd "$repo_path" > /dev/null

        # Get the current branch name
        curr_branch=$(git symbolic-ref --short HEAD 2>/dev/null)

        # Check if on 'main' and there are no uncommitted changes
        # The `--porcelain` flag outputs the status of the working directory and staging
        # area in a machine-readable format which is more concise, and script-friendly
        if [[ "$curr_branch" == "main" ]] && [[ -z "$(git status --porcelain)" ]]; then
          echo "Pulling latest changes in $repo..."
          git pull
          git fetch --prune
        else
          echo "Skipping $repo (not on 'main' or has uncommitted changes)."
        fi

        popd > /dev/null
      else
        echo "Skipping $repo (directory does not exist)."
      fi
      echo ""
  done

  # Return to the original directory
  cd "$original_dir"
}

function all-objects () {
  # Create temp file for branch mapping
  tmpfile=$(mktemp)
  datafile=$(mktemp)
  trap "rm -f $tmpfile $datafile" EXIT

  # Build object-to-branch mapping
  git branch -a | sed 's/^[* ]*//' | while read branch; do
    git rev-list --objects "$branch" | awk -v b="$branch" '{print $1 " " b}'
  done | sort | awk '{if(obj!=$1){if(obj)print obj " " branches; obj=$1; branches=$2} else branches=branches","$2} END{if(obj)print obj " " branches}' > "$tmpfile"

  # Process and save to temp file
  git rev-list --objects --all | 
  git cat-file --batch-check='%(objecttype) %(objectname) %(objectsize) %(rest)' | 
  sed -n 's/^blob //p' | 
  sort -k1,1 | 
  join -1 1 -2 1 -a 1 -o 1.1,1.2,1.3,2.2 - "$tmpfile" | 
  awk '{printf "%.7s %s %s %s\n", $1, ($4=="" ? "unknown" : $4), $2, $3}' > "$datafile"

  # Display sorted file list
  sort -r --numeric-sort --key=3 "$datafile" | 
  $(command -v gnumfmt || echo numfmt) --field=3 --to=si --suffix=B --padding=7 --round=nearest

  # Calculate and display branch totals
  echo ""
  echo "--------------------------- Branch Totals ---------------------------"
  awk '{
    size = $3
    branches = $2
    split(branches, branch_arr, ",")
    for (i in branch_arr) {
      branch_totals[branch_arr[i]] += size
    }
  }
  END {
    for (branch in branch_totals) {
      print branch " " branch_totals[branch]
    }
  }' "$datafile" | sort -k2 -rn | while read branch bytes; do
    formatted=$(echo "$bytes" | $(command -v gnumfmt || echo numfmt) --to=si --suffix=B --padding=7 --round=nearest)
    printf "%-60s %7s\n" "$branch" "$formatted"
  done
}
